{
  "key": "siegengin_architecture",
  "origin": "https://github.com/goodsun/siegeNgin",
  "title": "siegeNgin — Architecture",
  "date": "",
  "body": "# siegeNgin アーキテクチャ設計\n\n## ビジョン\n\n人間同士が会議室で **声とホワイトボード** を使って意思疎通するように、\nAIとの協働でも **チャットとコラボレーションツール** を併用した意思疎通を実現する。\n\nチャットだけのAI協働は「電話会議」に等しい。\nsiegeNginは、AIと人間が **同じものを同時に見ながら会話する** ための共有空間（ホワイトボード）を提供する。\n\n## 課題：チャットだけでは壁がある\n\n### 視覚的コンテキストの欠如\n\n```\n人間: 「Y軸のラベルをもう少し左に」\nAI:   「anchor=east で pos=0 にしますか？」\n人間: 「いや、そうじゃなくて…」\n      （数往復のやりとり）\n```\n\n図・レイアウト・UIの調整は、言語化のコストが極めて高い。\n「ここ」と指させれば一瞬で伝わることに、何往復もかかる。\n\n### データの共有が困難\n\n```\n人間: 「スプレッドシートの3行目のデータをこのフォームに入れて」\nAI:   「どのスプレッドシートですか？どのシートですか？」\n```\n\nデータソースと操作対象が分断されていて、AIが両方を同時に見られない。\n\n## コンセプト：3つの層\n\n### 1. チャット層（声）\n\n意図・議論・指示を伝える。\n\n- 既存のメッセージングツール（Telegram、Discord、Slack等）をそのまま利用\n- AIエージェント基盤（OpenClaw等）が仲介\n\n**siegeNginはチャット層を再発明しない。** 既存のエコシステムを活用する。\n\n### 2. 共有ビュー層（ホワイトボード）\n\nAIと人間が同じコンテキストを共有するブラウザベースのUI。\n\n複数のツールを同時に表示し、共有する窓：\n\n| ツール | 役割 | 例 |\n|--------|------|-----|\n| スプレッドシート | データソース | Google Sheets, CSV |\n| ブラウザビュー | 操作対象 | 業務フォーム, Webアプリ |\n| プレビュー | 出力結果 | PDF, 画像, コード差分 |\n| エディタ | 共同編集 | コード, 設計図 |\n\n### 3. ポインティング層（指さし）\n\n「これ」「ここ」を伝えるインタラクション。\n\n- ユーザがクリック/選択した要素をAIのコンテキストに変換\n- AIが理解可能なインターフェース（セレクタ、座標、セル参照等）を自動生成\n\n## コア機能\n\n### インターフェース自動生成\n\n既存のWebページやツールを読み込み、ユーザの「指さし」から操作可能なインターフェースを自動生成する。\n\n**先行実装: XPathGenie / Jasmine**\n\nJasmineは、既存Webページの要素をクリックで選択すると、XPath（操作パス）を自動生成する。\nこれはsiegeNginのインターフェース自動生成のプロトタイプにあたる。\n\n```\n既存Webサイト → 読み込み → ユーザが指さす → インターフェースを自動生成\n```\n\nこの仕組みを汎用化する：\n\n- Webページの要素 → DOM セレクタ / XPath\n- スプレッドシートのセル → セル参照（A3, B7等）\n- PDF/画像の領域 → 座標・バウンディングボックス\n- フォームの入力欄 → フィールド識別子\n\n### マスター自動判定\n\nチャット側のユーザと共有ビュー側のユーザを自動的に紐付ける。\nコラボレーションツールの認証情報を利用し、コマンドライン設定なしでユーザを特定する。\n\n### ブリッジ\n\n共有ビュー上のユーザ操作を、AIエージェントのコンテキストにリアルタイムで伝達する。\n\n```\n[ユーザ操作]              [AIコンテキスト]\nセルB3をクリック     →    「スプレッドシートの B3（値: 田中太郎）を選択」\nフォーム欄を指さし   →    「入力先: #name-field（ラベル: 氏名）」\nPDF領域を選択       →    「PDF 2ページ目、左上 (120,340) 付近のラベル」\n```\n\n## 設計原則\n\n### 1. 既存ツールを活かす\n\nsiegeNginは既存のエコシステムを置き換えない。\n\n- チャット → 既存メッセージングツール\n- AIエージェント → OpenClaw等の既存基盤\n- データ → Google Sheets等の既存サービス\n\nsiegeNginが担うのは **「つなぎ」** — 分断されたツール間の共有コンテキストを生む。\n\n### 2. ブラウザベース、サーバーレス志向\n\n- コマンドライン不要\n- 可能な限りクライアントサイドで完結\n- 参入障壁を最小化\n\n### 3. 指さしファースト\n\n言語化が難しいことは、指さしで伝える。\nGPUのように高速に視覚処理できる人間の能力を活かし、\n言語ボトルネックを回避する設計。\n\n## 既存資産との関係\n\n| プロジェクト | siegeNginにおける位置づけ |\n|-------------|------------------------|\n| XPathGenie / Jasmine | インターフェース自動生成のプロトタイプ |\n| ChatBot Lite | $0ブラウザUI設計パターン |\n| OpenClaw | チャット層のAIエージェント基盤 |\n| playwright-cli | AIからブラウザを操作する技術 |\n\n## データフローとセキュリティ\n\n### latest.json の保護方針\n\nChrome拡張から送られたポイントデータは、サーバーローカルの `latest.json` にフルデータ（テキスト内容・属性値を含む）で保存される。本隊（AIアシスタント）はこのファイルを直接読むため、城門のフィルタを経由しない。\n\n- **パーミッション**: `0600`（所有者のみ読み書き）\n- **保持期間**: 新しいポイントで上書き。履歴は直近10件のみ保持\n- **配置先**: ユーザー所有ディレクトリ（`~/.local/share/siegengin/`）。`/tmp` は使用しない\n- **サーバー侵害時**: `latest.json` が最も価値の高い標的となる。サーバー自体のセキュリティ（SSH鍵認証、ファイアウォール等）が前提\n\n### Wakeメカニズム\n\n足軽（伝令）がポイントデータを受け取った後、本隊を起こすトリガー：\n\n1. 足軽がサーバーローカルにデータを書き込み\n2. サーバーがAIエージェント基盤（OpenClaw等）にWakeイベントを送信（localhost webhook）\n3. 本隊がWakeで起動 → `latest.json` を読み取り → チャットチャネルで応答\n\nWakeはサーバー内部のlocalhost通信であり、城門を通らない。外部からのWake発火は不可。\n\n## 今後の検討事項\n\n- [ ] 共有ビューのUI設計（マルチペイン? タブ? フローティング?）\n- [ ] ブリッジのプロトコル設計（WebSocket? postMessage?）\n- [ ] 対応ツールの優先順位（スプレッドシート、フォーム、PDF…）\n- [ ] リアルタイム性の要件（同期的? 非同期?）\n- [ ] セキュリティモデル（APIキーの扱い、BYOK?）\n- [ ] OpenClawとの統合方式",
  "tags": "siegeNgin, Architecture, bon-soleil, product"
}